---
title: "The Gillespie Algorithm: Stochastic Modeling of Molecular Reaction Networks"
author: 
  - Jiayu Guo
  - Sinan Ma 
  - Anna Szydlowski
date: "`r Sys.Date()`"
output:
    number_sections: true
    citation_package: biblatex 
spacing: double
header-includes:
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[L]{Title of Project}
  - \fancyfoot[CO,CE]{}
  - \fancyfoot[LE,RO]{\thepage}
  - \usepackage{setspace}\doublespacing
bibliography: references.bib 
editor_options: 
  markdown: 
    wrap: 72
---

\newpage 
\tableofcontents 
\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Introduction

The Gillespie Algorithm was presented in 1976 by Daniel T. Gillespie (@Gillespie1976). This algorithm was developed  to answer the question, “If a fixed volume V contains a spatially uniform mixture of N chemical species which can inter-react through M specified chemical reaction channels, then given the numbers of molecules of each species present at some initial time, what will these molecular population levels be at any later time?” (@Gillespie1977). Given the trajectory of this molecular reaction is a stochastic process, this algorithm can simulate various molecular equation systems, such as radioactive decay models or decaying-dimerization reaction sets (@GillespieSSA).

In the following report, we will review basic concepts of the Gillespie Algorithm [Topic Review section](#sec-Topic-Review), then we will present the theory of the Gillespie Algorithm [Theory section](#sec-theory). Afterwards, we will demonstrate a stochastic simulation using the Gillespie algorithm of a dimerization reaction set [APplication section](#sec-application), using R(@citeR). Finally, we will provide our concluding remarks [Conclusion section](#sec-conclusion).


# Topic Review {#sec-Topic-Review}

When you click the **Knit** button a document will be generated that
includes both content as well as the output of any embedded R code
chunks within the document. You can embed an R code chunk like this:

```{r cars,comment=NA}
summary(cars)
```

You can also embed publication quality plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

## Definitions and Examples

Such as importance of longitudinal data analysis (separate age and
cohort effect like in the effect of age on reading ability), different
correlation structures, missing data, etc.

## Details of the topic

This is a mathematical formua without formula number.
$$h(x) = \frac{f(x)}{S(x)} = -\frac{d \log[S(x])}{\rm dx}$$

This is how write a fomula and label it. \begin{align}
\label{eq2}
S(x) = \exp[-H(x)] = \exp[-\int_0^x h(u) {\rm d}u]
\end{align}

# Theory {#sec-theory}
# Application {#sec-application}
## Photodimerization Simulation
We can simulate the dimerization of DNA pyrimidines, a molecular reaction which can lead to skin cancer. Bipyrimidine photodimerization occurs when UV radiation alters the chemical bonds of two consecutive pyrimidine bases, with two possible outcomes: the formation of the cyclobutene pyrimidine dimer (CPD) if a cycloaddition between the C5-C6 double bond of the pyrimidines occurs, or the formation of pyrimidine (6-4) pyrimidone (64-PP) if  a covalent bond forms between C4 and C6 of the pyrimidines (@MartinezFernandez2022).

Therefore, this simulation involves 4 species and 3 reactions channels: pyrimidine monomers Thymine 1 (T1), Thymine 2 (T2), and dimer photoproducts CPD and 64-PP. 

We will simulate the dimerization of thymine using propensity based on the formation yield of CPD (~37 per 10^6 normal bases) and 64-PP (~2 per 10^6 normal bases) found by exposing skin cells to a UVB dose of 0.2 J/cm^2 (@Mouret2006). As the amount of thymine bases in DNA varies from person to person, we will simulate thymine photodimerization of 1000 pairs of thymine.

```{r simulation_1, echo=FALSE, warning=FALSE, message=FALSE}
# Load required libraries
if (!require("reshape2")) install.packages("reshape2")
if (!require("ggplot2")) install.packages("ggplot2")
library(reshape2)
library(ggplot2)
# Define reaction rates
c1 <- (1 - (37 + 2) / 1e6) * 10   # No dimerization occurs
c2 <- (37 / 1e6) * 10             # Formation of CPD
c3 <- (2 / 1e6) * 10              # Formation of 64-PP
# Initial state
state <- c(T1 = 10000, T2 = 10000, CPD = 0, `64PP` = 0)
# Define propensity functions
propensities <- function(state) {
  c(
    c1 * state["T2"],               # Reaction 1
    c2 * state["T1"] * state["T2"], # Reaction 2
    c3 * state["T2"]                # Reaction 3
  )
}
# Gillespie simulation function
simulate_gillespie <- function(state, max_time) {
  # Initialize time and output data frame
  time <- 0
  output <- data.frame(
    Time = numeric(0),
    T1 = numeric(0),
    T2 = numeric(0),
    CPD = numeric(0),
    `64PP` = numeric(0)
  )
  
  # Record the initial state
  initial_row <- c(Time = time, state)
  output <- rbind(output, as.data.frame(t(initial_row), stringsAsFactors = FALSE))
  
  while (time < max_time) {
    # Calculate propensities
    props <- propensities(state)
    total_prop <- sum(props)
    
    # Stop if no reactions can occur
    if (total_prop == 0) break
    
    # Time to next reaction
    delta_t <- rexp(1, rate = total_prop)
    time <- time + delta_t
    
    # Select which reaction occurs
    reaction <- sample(length(props), 1, prob = props)
    
    # Update state based on reaction
    if (reaction == 1) state["T2"] <- state["T2"] - 1
    if (reaction == 2) {
      state["T1"] <- state["T1"] - 1
      state["T2"] <- state["T2"] - 1
      state["CPD"] <- state["CPD"] + 1
    }
    if (reaction == 3) {
      state["T2"] <- state["T2"] - 1
      state["64PP"] <- state["64PP"] + 1
    }
    
    # Record the new state
    new_row <- c(Time = time, state)
    output <- rbind(output, as.data.frame(t(new_row), stringsAsFactors = FALSE))
  }
  
  # Convert columns to numeric for consistency
  output[] <- lapply(output, as.numeric)
  return(output)
}
# Run the simulation
max_time <- 100
simulation <- simulate_gillespie(state, max_time)
```

```{r graph_1, echo=FALSE, warning=FALSE, message=FALSE}
# Reshape data for plotting
simulation_long <- melt(simulation, id.vars = "Time")
# Plot results
ggplot(simulation_long, aes(x = Time, y = value, color = variable)) +
  geom_line() +
  labs(
    title = "Decay-Dimerization Reaction Set Simulation",
    x = "Time",
    y = "Molecule Count",
    color = "Species"
  ) +
  theme_minimal()
```

## Radioactive Decay Simulation

This simulation models the stochastic decay of a single species (\( R \)), which represents a radioactive substance such as radon, radium, or plutonium. The decay process is governed by the following reaction:

\[
R \xrightarrow{c} 0
\]

where \( c \) is the decay rate constant that defines the likelihood of decay per unit time.

The Gillespie algorithm is used to simulate this system, capturing the inherent randomness of radioactive decay events. Unlike deterministic approaches, the Gillespie algorithm tracks individual decay events over time, providing an accurate representation of the stochastic nature of the process. The goal of this simulation is to observe the time evolution of the remaining radioactive molecules (\( R \)) and visualize their decay over time.


```{r simulation_2, echo=FALSE, warning=FALSE, message=FALSE}
# Define parameters
c <- 0.01  # Decay rate constant
state <- c(R = 10000)  # Initial radioactive substance
max_time <- 1000  # Extended maximum simulation time

# Define propensity function
propensities <- function(state) {
  c * state["R"]
}

# Gillespie simulation function
simulate_gillespie <- function(state, max_time) {
  time <- 0
  output <- data.frame(Time = numeric(0), R = numeric(0))
  output <- rbind(output, data.frame(Time = time, R = state["R"]))
  
  while (time < max_time) {
    # Calculate propensity
    prop <- propensities(state)
    if (prop == 0) break  # Stop if no reactions can occur
    
    # Time to next reaction
    delta_t <- rexp(1, rate = prop)
    time <- time + delta_t
    
    # Update state (decay reaction)
    state["R"] <- state["R"] - 1
    
    # Record the state
    output <- rbind(output, data.frame(Time = time, R = state["R"]))
  }
  
  return(output)
}

# Run the simulation
simulation <- simulate_gillespie(state, max_time)

```

```{r decay-linear, echo=FALSE, warning=FALSE, message=FALSE, fig.cap="Radioactive Decay Simulation in Linear Scale"}

# Load ggplot2 for visualization
library(ggplot2)

# Linear-scale plot
ggplot(simulation, aes(x = Time, y = R)) +
  geom_line(color = "blue") +
  labs(
    x = "Time",
    y = "Remaining Radioactive Substance (R)"
  ) +
  theme_minimal()
```


```{r decay-log, echo=FALSE, warning=FALSE, message=FALSE, fig.cap="Radioactive Decay Simulation in Logarithmic Scale"}
# Logarithmic-scale plot
ggplot(simulation, aes(x = Time, y = R)) +
  geom_line(color = "red") +
  scale_y_log10() +
  labs(
    x = "Time",
    y = "Remaining Radioactive Substance (log(R))"
  ) +
  theme_minimal()

```

### Observations

The simulation results are visualized in two plots. Figure \@ref(fig:decay-linear) shows the decay on a linear scale, while Figure \@ref(fig:decay-log) presents the same data on a logarithmic scale to highlight the exponential nature of the decay process.

#### Exponential Decay
The radioactive substance (\( R \)) decays exponentially over time, as expected from the properties of radioactive decay. In Figure \@ref(fig-decay-linear), this behavior is reflected in the steep decline in \( R \) during the early stages of the simulation, followed by a more gradual decline as the remaining quantity of \( R \) decreases. This is consistent with the exponential decay law:

\[
R(t) = R_0 e^{-ct}
\]

where \( R_0 \) is the initial amount, \( c \) is the decay constant, and \( t \) is time. The propensity function \( a(R) = c \cdot R \) ensures that the decay rate is proportional to the remaining amount of \( R \).

In Figure \@ref(fig-decay-log), the decay trajectory appears as a straight line, which confirms the exponential nature of the process. The slope of this line corresponds to the decay constant \( c \), validating the theoretical prediction.

#### Stochastic Fluctuations
Unlike deterministic simulations, the stochastic approach introduces minor fluctuations in the timing of individual decay events. These fluctuations are more noticeable when the number of molecules is small, as random variations in the timing of events have a larger relative impact.

#### Time Steps and Decay Events
As the number of molecules decreases, the propensity \( a(R) \) becomes smaller, leading to larger intervals (\( \Delta t \)) between successive decay events. This dynamic is evident in both figures, where the rate of decline slows significantly in the later stages of the simulation.

### Biological and Physical Significance

#### Radioactive Half-Life
The exponential decay observed in this simulation aligns with the concept of half-life, the time required for half of the substance to decay. The half-life (\( t_{1/2} \)) can be computed as:

\[
t_{1/2} = \frac{\ln(2)}{c}
\]

For \( c = 0.01 \), the half-life is approximately \( t_{1/2} \approx 69.3 \) time units. This simulation demonstrates how the decay rate diminishes over time as the remaining radioactive substance depletes.

#### Real-World Applications
Radioactive decay is a fundamental process in nuclear physics, medicine, and environmental science. For example, it is critical in radiotherapy for cancer treatment, where the controlled decay of radioactive isotopes delivers targeted doses of radiation. It also has applications in monitoring environmental contaminants such as radon gas, where stochastic decay processes affect detection and measurement accuracy. Understanding the inherent randomness of decay is essential for accurate predictions, especially in low-count systems where stochastic effects dominate.


# Conclusion {#sec-conclusion}

# References