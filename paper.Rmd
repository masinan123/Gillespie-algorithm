---
title: "The Gillespie Algorithm: Stochastic Modeling of Molecular Reaction Networks"
author: 
  - Jiayu Guo
  - Sinan Ma 
  - Anna Szydlowski
date: "`r Sys.Date()`"
output:
  pdf_document:
    number_sections: true
    citation_package: biblatex 
spacing: double
header-includes:
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[L]{Title of Project}
  - \fancyfoot[CO,CE]{}
  - \fancyfoot[LE,RO]{\thepage}
  - \usepackage{setspace}\doublespacing
bibliography: references.bib 
editor_options: 
  markdown: 
    wrap: 72
---

\newpage 
\tableofcontents 
\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Introduction

The Gillespie Algorithm was presented in 1976 by Daniel T. Gillespie (@Gillespie1976). This algorithm was developed  to answer the question, “If a fixed volume V contains a spatially uniform mixture of N chemical species which can inter-react through M specified chemical reaction channels, then given the numbers of molecules of each species present at some initial time, what will these molecular population levels be at any later time?” (@Gillespie1977). Given the trajectory of this molecular reaction is a stochastic process, this algorithm can simulate various molecular equation systems, such as radioactive decay models or decaying-dimerization reaction sets (@GillespieSSA).

In the following report, we will review basic concepts of the Gillespie Algorithm (Section 2), then we will present the theory of the Gillespie Algorithm (Section 3). Afterwards, we will demonstrate a stochastic simulation using the Gillespie algorithm of a dimerization reaction set (Section 4), using R(@citeR). Finally, we will provide our concluding remarks (Section 5).


# Review of the Topic

When you click the **Knit** button a document will be generated that
includes both content as well as the output of any embedded R code
chunks within the document. You can embed an R code chunk like this:

```{r cars,comment=NA}
summary(cars)
```

You can also embed publication quality plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

## Definitions and Examples

Such as importance of longitudinal data analysis (separate age and
cohort effect like in the effect of age on reading ability), different
correlation structures, missing data, etc.

## Details of the topic

This is a mathematical formua without formula number.
$$h(x) = \frac{f(x)}{S(x)} = -\frac{d \log[S(x])}{\rm dx}$$

This is how write a fomula and label it. \begin{align}
\label{eq2}
S(x) = \exp[-H(x)] = \exp[-\int_0^x h(u) {\rm d}u]
\end{align}

# Application
We can simulate the dimerization of DNA pyrimidines, a molecular reaction which can lead to skin cancer. Bipyrimidine photodimerization occurs when UV radiation alters the chemical bonds of two consecutive pyrimidine bases, with two possible outcomes: the formation of the cyclobutene pyrimidine dimer (CPD) if a cycloaddition between the C5-C6 double bond of the pyrimidines occurs, or the formation of pyrimidine (6-4) pyrimidone (64-PP) if  a covalent bond forms between C4 and C6 of the pyrimidines (@MartinezFernandez2022).
    
Therefore, this simulation involves 4 species and 3 reactions channels: pyrimidine monomers Thymine 1 (T1), Thymine 2 (T2), and dimer photoproducts CPD and 64-PP. 

We will simulate the dimerization of thymine using propensity based on the formation yield of CPD (~37 per 10^6 normal bases) and 64-PP (~2 per 10^6 normal bases) found by exposing skin cells to a UVB dose of 0.2 J/cm^2 (@Mouret2006). As the amount of thymine bases in DNA varies from person to person, we will simulate thymine photodimerization of 1000 pairs of thymine.

```{r simulation_1, echo=FALSE}
# Load required libraries
library(reshape2)
library(ggplot2)

# Define reaction rates
c1 <- (1 - (37 + 2) / 1e6) * 10   # No dimerization occurs
c2 <- (37 / 1e6) * 10             # Formation of CPD
c3 <- (2 / 1e6) * 10              # Formation of 64-PP

# Initial state
state <- c(T1 = 10000, T2 = 10000, CPD = 0, `64PP` = 0)

# Define propensity functions
propensities <- function(state) {
  c(
    c1 * state["T2"],               # Reaction 1
    c2 * state["T1"] * state["T2"], # Reaction 2
    c3 * state["T2"]                # Reaction 3
  )
}

# Gillespie simulation function
simulate_gillespie <- function(state, max_time) {
  # Initialize time and output data frame
  time <- 0
  output <- data.frame(
    Time = numeric(0),
    T1 = numeric(0),
    T2 = numeric(0),
    CPD = numeric(0),
    `64PP` = numeric(0)
  )
  
  # Record the initial state
  initial_row <- c(Time = time, state)
  output <- rbind(output, as.data.frame(t(initial_row), stringsAsFactors = FALSE))
  
  while (time < max_time) {
    # Calculate propensities
    props <- propensities(state)
    total_prop <- sum(props)
    
    # Stop if no reactions can occur
    if (total_prop == 0) break
    
    # Time to next reaction
    delta_t <- rexp(1, rate = total_prop)
    time <- time + delta_t
    
    # Select which reaction occurs
    reaction <- sample(length(props), 1, prob = props)
    
    # Update state based on reaction
    if (reaction == 1) state["T2"] <- state["T2"] - 1
    if (reaction == 2) {
      state["T1"] <- state["T1"] - 1
      state["T2"] <- state["T2"] - 1
      state["CPD"] <- state["CPD"] + 1
    }
    if (reaction == 3) {
      state["T2"] <- state["T2"] - 1
      state["64PP"] <- state["64PP"] + 1
    }
    
    # Record the new state
    new_row <- c(Time = time, state)
    output <- rbind(output, as.data.frame(t(new_row), stringsAsFactors = FALSE))
  }
  
  # Convert columns to numeric for consistency
  output[] <- lapply(output, as.numeric)
  return(output)
}

# Run the simulation
max_time <- 100
simulation <- simulate_gillespie(state, max_time)

```

```{r graph_1, echo=FALSE}
# Reshape data for plotting
simulation_long <- melt(simulation, id.vars = "Time")

# Plot results
ggplot(simulation_long, aes(x = Time, y = value, color = variable)) +
  geom_line() +
  labs(
    title = "Decay-Dimerization Reaction Set Simulation",
    x = "Time",
    y = "Molecule Count",
    color = "Species"
  ) +
  theme_minimal()

```


## Radioactive Decay Simulation

This simulation models the stochastic decay of a single species (\( R \)), which represents a radioactive substance such as radon, radium, or plutonium. The decay process is governed by the following reaction:

\[
R \xrightarrow{c} 0
\]

where \( c \) is the decay rate constant that defines the likelihood of decay per unit time.

The Gillespie algorithm is used to simulate this system, capturing the inherent randomness of radioactive decay events. Unlike deterministic approaches, the Gillespie algorithm tracks individual decay events over time, providing an accurate representation of the stochastic nature of the process.

The goal of this simulation is to observe the time evolution of the remaining radioactive molecules (\( R \)) and visualize their decay over time.
```{r simulation_2, echo=FALSE}
# Define parameters
c <- 0.01  # Decay rate constant
state <- c(R = 1000)  # Initial radioactive substance
max_time <- 100  # Maximum simulation time

# Define propensity function
propensities <- function(state) {
  c * state["R"]
}

# Gillespie simulation function
simulate_gillespie <- function(state, max_time) {
  time <- 0
  output <- data.frame(Time = numeric(0), R = numeric(0))
  output <- rbind(output, data.frame(Time = time, R = state["R"]))
  
  while (time < max_time) {
    # Calculate propensity
    prop <- propensities(state)
    if (prop == 0) break  # Stop if no reactions can occur
    
    # Time to next reaction
    delta_t <- rexp(1, rate = prop)
    time <- time + delta_t
    
    # Update state (decay reaction)
    state["R"] <- state["R"] - 1
    
    # Record the state
    output <- rbind(output, data.frame(Time = time, R = state["R"]))
  }
  
  return(output)
}

# Run the simulation
simulation <- simulate_gillespie(state, max_time)

```

```{r graph_2, echo=FALSE}
library(ggplot2)

# Plot results
ggplot(simulation, aes(x = Time, y = R)) +
  geom_line(color = "blue") +
  labs(
    title = "Radioactive Decay Simulation",
    x = "Time",
    y = "Remaining Radioactive Substance (R)"
  ) +
  theme_minimal()

```

### Observations

1. **Exponential Decay**:
   - The radioactive substance (\( R \)) decays exponentially over time, as expected from the properties of radioactive decay. The number of decay events per unit time decreases as the quantity of \( R \) diminishes.
   - This behavior is reflected in the propensity function \( a(R) = c \cdot R \), where the decay rate is proportional to the remaining amount of \( R \).

2. **Stochastic Fluctuations**:
   - Unlike a smooth deterministic decay curve, the simulation shows small fluctuations in the timing of decay events. These fluctuations arise from the stochastic nature of the Gillespie algorithm, which models each decay event as a probabilistic process.

3. **Time Steps and Decay Events**:
   - The time intervals between decay events (\( \Delta t \)) grow longer as the number of \( R \) molecules decreases. This is because the propensity (\( a(R) \)) becomes smaller, leading to larger expected time intervals between events.

### Biological/Physical Significance

- **Radioactive Half-Life**:
  - The exponential decay observed in this simulation is consistent with the concept of half-life in radioactive decay. While this model does not explicitly compute the half-life, it demonstrates how the decay rate slows down as the substance depletes.

- **Real-World Applications**:
  - Radioactive decay processes are critical in many fields, including nuclear physics, medicine (e.g., radiotherapy), and environmental science (e.g., radon gas monitoring). Understanding stochastic decay helps refine predictions in low-count systems where randomness plays a significant role.


# Conclusion

# References
